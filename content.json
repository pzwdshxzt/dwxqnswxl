{"meta":{"title":"When I think of you, I smile.","subtitle":"My mother wouldn't let me play with fools.","description":"Love and peace cosmopolitanism","author":"Huangjinxing","url":"https://www.dwxnqswxl.cn"},"pages":[{"title":"about me","date":"2018-08-22T07:36:22.000Z","updated":"2018-08-24T08:12:55.802Z","comments":true,"path":"about/index.html","permalink":"https://www.dwxnqswxl.cn/about/index.html","excerpt":"","text":""},{"title":"cool","date":"2018-08-24T08:11:04.000Z","updated":"2018-08-24T08:12:25.302Z","comments":true,"path":"cool/index.html","permalink":"https://www.dwxnqswxl.cn/cool/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-08-22T07:36:22.000Z","updated":"2018-08-22T09:15:28.419Z","comments":false,"path":"categories/index.html","permalink":"https://www.dwxnqswxl.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-22T07:36:22.000Z","updated":"2018-08-22T09:15:06.107Z","comments":false,"path":"tags/index.html","permalink":"https://www.dwxnqswxl.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HashMap（JDK1.8）源码阅读记录","slug":"YM00000001","date":"2018-08-17T08:55:30.000Z","updated":"2018-08-24T03:14:02.150Z","comments":true,"path":"2018/08/17/YM00000001/","link":"","permalink":"https://www.dwxnqswxl.cn/2018/08/17/YM00000001/","excerpt":"HashMap基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。 数据结构先看下hashmap的数据结构大概就是如图所示。table就是数组咯。链表的他们称之为桶。大于阈值就转成红黑树咯，主要是为了提高效率。使用红黑树来实现。 构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; /** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; 其中最主要的是初始化的大小还有初始化填充因子static final float DEFAULT_LOAD_FACTOR = 0.75f;HashMap的容量超过当前数组长度 X 加载因子，就会执行resize()算法比如说向水桶中装水，此时HashMap就是一个桶， 这个桶的容量就是加载容量，而加载因子就是你要控制向这个桶中倒的水不超过水桶容量的比例，比如加载因子是0.75 ，那么在装水的时候这个桶最多能装到3/4 处，超过这个比例时，桶会自动扩容。因此，这个桶最多能装水 = 桶的容量 X 加载因子。 12345678910111213141516/** * 获取初始值，你输入的初始值，不一定是初始化时所用的初始值。 * 为什么初始值必须是2得倍数呢，下面代码会给你解释。 * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; MAXIMUM_CAPACITY = 1&lt;&lt;30; 这样得到的始终是你输入初始值小于最小的2的次幂，也就是说比如你输入15 —&gt;&gt;1629 —&gt;&gt;3244 —&gt;&gt;64为什么初始倍数一定要2^n呢？ 重要函数hash()12345678910111213141516171819202122/** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don't benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. */ static final int hash(Object key) &#123; int h; // 这一顿操作大概的意思就是保留了高16位的值 // 其实低16位得值也保留了下来，只要在做一次异或，值就变回来了 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125;","text":"HashMap基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高（或将加载因子设置得太低）。 数据结构先看下hashmap的数据结构大概就是如图所示。table就是数组咯。链表的他们称之为桶。大于阈值就转成红黑树咯，主要是为了提高效率。使用红黑树来实现。 构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; /** * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;HashMap&lt;/tt&gt; is created with * default load factor (0.75) and an initial capacity sufficient to * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;. * * @param m the map whose mappings are to be placed in this map * @throws NullPointerException if the specified map is null */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; 其中最主要的是初始化的大小还有初始化填充因子static final float DEFAULT_LOAD_FACTOR = 0.75f;HashMap的容量超过当前数组长度 X 加载因子，就会执行resize()算法比如说向水桶中装水，此时HashMap就是一个桶， 这个桶的容量就是加载容量，而加载因子就是你要控制向这个桶中倒的水不超过水桶容量的比例，比如加载因子是0.75 ，那么在装水的时候这个桶最多能装到3/4 处，超过这个比例时，桶会自动扩容。因此，这个桶最多能装水 = 桶的容量 X 加载因子。 12345678910111213141516/** * 获取初始值，你输入的初始值，不一定是初始化时所用的初始值。 * 为什么初始值必须是2得倍数呢，下面代码会给你解释。 * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; MAXIMUM_CAPACITY = 1&lt;&lt;30; 这样得到的始终是你输入初始值小于最小的2的次幂，也就是说比如你输入15 —&gt;&gt;1629 —&gt;&gt;3244 —&gt;&gt;64为什么初始倍数一定要2^n呢？ 重要函数hash()12345678910111213141516171819202122/** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower. Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.) So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don't benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. */ static final int hash(Object key) &#123; int h; // 这一顿操作大概的意思就是保留了高16位的值 // 其实低16位得值也保留了下来，只要在做一次异或，值就变回来了 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; public V put(K key, V value) {}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; /** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table未初始化或者长度为0，进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 看下值放在哪一个table[] // 这里也有一个为什么table的大小为什么必须是2的倍数的原因 // n 是 tab的长度 那么 (n - 1) &amp; hash 的意思就是？ // 假如 长度为 16(10000) 那么 15(01111) &amp; 就得到最后hash值相当于 h &amp; (length - 1) == h % length // 这样数组也不会越界等 运算得比%运算得快 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 已经有了，就看下是放在 链表还是红黑树。 else &#123; Node&lt;K,V&gt; e; K k; //先比较s是不是在头节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //或者是红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //没办法了，只能是链表了 else &#123; for (int binCount = 0; ; ++binCount) &#123; //直接放在尾部 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //链表大于8个阈值直接转成红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //存在一模一样的key则跳出继续 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; //继续遍历 p = e; &#125; &#125; //如果找到了存放的位置 if (e != null) &#123; // existing mapping for key V oldValue = e.value; // onlyIfAbsent为false或者旧值为null // onlyIfAbsent是传入的参数 默认w为false直接替换 if (!onlyIfAbsent || oldValue == null) //用新值替换旧值 e.value = value; afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; ++modCount; // 实际大小大于阈值则扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; public V get(Object key) {}相对于put，get就比较简单了。相对jdk1.7版本1.7 —-&gt;1.8位桶+链表 —-&gt; 位桶+链表大于阈值（8）后切换成红黑树大数据下 O(n)-&gt;&gt;O(Logn) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Returns the value to which the specified key is mapped, * or &#123;@code null&#125; if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * &#123;@code k&#125; to a value &#123;@code v&#125; such that &#123;@code (key==null ? k==null : * key.equals(k))&#125;, then this method returns &#123;@code v&#125;; otherwise * it returns &#123;@code null&#125;. (There can be at most one such mapping.) * * &lt;p&gt;A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it's also * possible that the map explicitly maps the key to &#123;@code null&#125;. * The &#123;@link #containsKey containsKey&#125; operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */ public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; /** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */ final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // table已经初始化，长度大于0，根据hash寻找table中的项也不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //判断是不是第一个结点 是就返回 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 节点下面还有东西？ if ((e = first.next) != null) &#123; // 是红黑树吗？ if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //不是红黑树那你肯定是链表咯 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; resize()hashmap的扩容方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */ final Node&lt;K,V&gt;[] resize() &#123; //保存旧的 Node&lt;K,V&gt;[] oldTab = table; //保存长度 int oldCap = (oldTab == null) ? 0 : oldTab.length; //保存阈值 需要resize的阈值 int oldThr = threshold; int newCap, newThr = 0; // 之前table大小大于0 if (oldCap &gt; 0) &#123; // 之前table大于最大容量 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 阈值为最大整形 threshold = Integer.MAX_VALUE; return oldTab; &#125; // 容量翻倍，使用左移，效率更高 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // double threshold 阈值翻倍 newThr = oldThr &lt;&lt; 1; // 之前阈值大于0 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; // oldCap = 0并且oldThr = 0，使用缺省值（如使用HashMap()构造函数，之后再插入一个元素会调用resize函数，会进入这一步） else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 新阈值为0 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) // 初始化table Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 之前的table已经初始化过 if (oldTab != null) &#123; // 复制元素，重新进行hash for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; //如果链表只有一个，则直接赋值 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; //红黑树啊 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //只能是链表了 else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 这一顿操作之后大概就是这个过程吧 #ENDHashMap运用了许多非常巧妙的算法吧，大量的使用到了位运算，让这个结构运行更稳定更巧妙。每次看都有新收获。","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dwxnqswxl.cn/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.dwxnqswxl.cn/tags/基础/"},{"name":"HashMap","slug":"HashMap","permalink":"https://www.dwxnqswxl.cn/tags/HashMap/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://www.dwxnqswxl.cn/tags/源码阅读/"}]},{"title":"JDK的弃儿：Vector、Stack、Hashtable、Enumeration","slug":"YM00000003","date":"2018-08-16T03:22:33.000Z","updated":"2018-08-24T02:12:28.825Z","comments":true,"path":"2018/08/16/YM00000003/","link":"","permalink":"https://www.dwxnqswxl.cn/2018/08/16/YM00000003/","excerpt":"","text":"随着JDK的发展，一些设计缺陷或者性能不足的类库难免会被淘汰，最常见的就是Vector、Stack、HashTable和Enumeration了。 Vector（@since 1.0）首先看看Vector的UML类图，可以看出，他是一个与ArrayList有着相同继承体系的类，大致功能也和ArrayList一样。Vector与ArrayList最大的不同点在于它是线程安全的，因为其内部几乎所有方法都用了synchronized来修饰。但是，Synchronized是重量级锁，读写操作也没有做适当的并发优化，已经被并发性更好的CopyOnWriteArrayList取代了。所以，当不要求线程安全时，自然会选择ArrayList，如果要求线程安全，往往也会选择CopyOnWriteArrayList或者Collections.synchronizedList()。 Stack（@since 1.0）Stack是Vector的子类，其内部的方法也都是通过无脑加synchronized来实现的，所以虽然线程安全，但是并发性不高。当不要求线程安全时，会选择LinkedList或者ArrayList（LinkedList的API更接近栈的操作，所以最佳选择是LinkedList），当要求线程安全时，我们会用java.util.concurrent包下的某些类。再多句嘴，虽然LinkedList的API比较接近栈的操作，但是暴露了许多用不着的方法，这会带来危险。解决方法是编写一个LinkedList的包装类，只暴露与栈相关的方法。 12345678910111213141516171819202122232425** * 包装&#123;@code LinkedList&#125;，使其仅暴露与栈相关的方法 */public class Stack&lt;T&gt; &#123; private LinkedList&lt;T&gt; list; public Stack() &#123; list = new LinkedList&lt;&gt;(); &#125; public void push(T item) &#123; list.push(item); &#125; public T pop() &#123; return list.pop(); &#125; public T peek() &#123; return list.peek(); &#125; public boolean isEmpty() &#123; return list.isEmpty(); &#125; @Override public String toString() &#123; return list.toString(); &#125;&#125; Hashtable(@since JDK1.0)首先看看Hashtable的UML类图，关键点是其实现了Map接口，所以它是一个存储键值对的容器。通过查看源码，我们知道，其是一个线程安全的类，而且还是用synchronized来实现的，所以并发性不高。所以，当面对不要求线程安全的应用场景时我们会用HashMap代替，要求线程安全的应用场景我们往往也会用ConcurrentHashMap或者Collections.synchronizedMap()来代替。再再多句嘴，它与HashMap还有一个比较出名的不同点，就是它的散列表实现算法是用线性探测法实现的，该算法要求key不能为null，不然删除键值对时会出问题。另外还要求value不能为null。具体见源码。 1234567891011121314151617181920212223242526272829303132333435public synchronized V put(K key, V value) &#123; // Make sure the value is not null if (value == null) &#123; //value不能为null throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); //key不可以为null int index = (hash &amp; 0x7FFFFFFF) % tab.length; @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index]; for(; entry != null ; entry = entry.next) &#123; if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123; V old = entry.value; entry.value = value; return old; &#125; &#125; addEntry(hash, key, value, index); return null;&#125;public synchronized boolean contains(Object value) &#123; if (value == null) &#123; throw new NullPointerException();//value不能为null &#125; Entry&lt;?,?&gt; tab[] = table; for (int i = tab.length ; i-- &gt; 0 ;) &#123; for (Entry&lt;?,?&gt; e = tab[i] ; e != null ; e = e.next) &#123; if (e.value.equals(value)) &#123; return true; &#125; &#125; &#125; return false;&#125; Enumeration(@since JDK1.0)Enumeration是否是JDK的“弃儿”其实是有争论的，有人认为，有了Iterator的存在，Enumeration存在的意义就仅仅是兼容老API（比如Vector、Hashtable）了；又有人认为，Enumeration提供了比Iterator更明确的语义（明确不希望对象被执行移除操作）。 123451 * NOTE: The functionality of this interface is duplicated by the Iterator2 * interface. In addition, Iterator adds an optional remove operation, and3 * has shorter method names. New implementations should consider using4 * Iterator in preference to Enumeration.5 这个接口的功能与Iterator接口重复了。此外，Iteraotr还有一个可选的remove()方法和更短的名字，新应用应该优先考虑Iterator。 总之，根据API的说明，我们得知，新应用应优先考虑Iterator接口。再再再多句嘴，万一要面对Enumeration，又想有个关于迭代的统一接口，可以使用适配器模式来处理Enumeration。 1234567891011121314151617181920212223242526272829** * 把Enumeration接口转换成Iterator接口的适配器 * 适配器模式中的角色 - adaptor */ public class EnumerationIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; /** * 被适配的接口 * 适配器模式中的角色 - adaptee */ private Enumeration&lt;E&gt; enums; public EnumerationIterator(Enumeration&lt;E&gt; enums) &#123; this.enums = enums; &#125; @Override public boolean hasNext() &#123; return enums.hasMoreElements(); &#125; @Override public E next() &#123; return enums.nextElement(); &#125; /** * 因为Enumeration接口不支持remove操作，所以这里简单地抛出异常 */ @Override public void remove() &#123; throw new UnsupportedOperationException(); &#125; &#125; 总结Vector、Stack、Hashtable由于其自身的设计不足而且又有替代的工具，所以在新项目中已难寻其踪。Iterator的强大功能也使Enumeration处境尴尬，也已经很少见到了。 本文转自JDK的弃儿：Vector、Stack、Hashtable、Enumeration-付大石 引用Java中，遍历数据结构Enumeration和Iterator相比有什么优劣？一个简单的适配器模式例子","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dwxnqswxl.cn/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.dwxnqswxl.cn/tags/基础/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://www.dwxnqswxl.cn/tags/源码阅读/"},{"name":"Vector","slug":"Vector","permalink":"https://www.dwxnqswxl.cn/tags/Vector/"},{"name":"Stack","slug":"Stack","permalink":"https://www.dwxnqswxl.cn/tags/Stack/"},{"name":"Hashtable","slug":"Hashtable","permalink":"https://www.dwxnqswxl.cn/tags/Hashtable/"},{"name":"Enumeration","slug":"Enumeration","permalink":"https://www.dwxnqswxl.cn/tags/Enumeration/"}]},{"title":"LinkedList（JDK1.8） 源码阅读记录","slug":"YM00000002","date":"2018-08-03T08:07:06.000Z","updated":"2018-08-27T09:06:06.585Z","comments":true,"path":"2018/08/03/YM00000002/","link":"","permalink":"https://www.dwxnqswxl.cn/2018/08/03/YM00000002/","excerpt":"","text":"LinkedList LinkedList是基于双向循环链表（从源码中可以很容易看出）实现的，除了可以当做链表来操作外，它还可以当做栈、队列和双端队列来使用。 LinkedList同样是非线程安全的，只在单线程下适合使用。 LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。 先看LinkedList数据结构 1234567891011121314/** 再看下这个节点吧 * LinkedList中的内部类 */private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 根据JDK版本的不同 ，构造方法也不同12345678910111213141516171819202122232425262728293031323334353637383940414243/** * JDK1.8 * Deque接口，Deque接口表示是一个双端队列，那么也意味着LinkedList是双端队列的一种实现， * 所以，实现了基于双端队列的所有操作。 */public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; /** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; /** * Constructs an empty list. */ public LinkedList() &#123; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; 1234567891011121314151617181920/** * 构造方法在1.6版本也不太一样 * 默认构造函数：创建一个空的链表 */ public LinkedList() &#123; header.next = header.previous = header; &#125; /** * 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。 相当于1.8 Node */private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null); /** * 包含“集合”的构造函数:创建一个包含“集合”的LinkedList */ public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 因为数据结构不大一样 所以add方式也不一样 * remove方式 实现方式有一点不一样 */ /** * JDK1.8 节点Node * Links e as last element. */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; /** * Unlinks non-null node x. */ E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; /** * JDK1.6 节点Entry * 将节点(节点数据是e)添加到entry节点之前。 */ private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123; // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; // 修改LinkedList大小 size++; // 修改LinkedList的修改统计数：用来实现fail-fast机制。 modCount++; return newEntry; &#125; /** * 将节点从链表中删除 */ private E remove(Entry&lt;E&gt; e) &#123; if (e == header) throw new NoSuchElementException(); E result = e.element; e.previous.next = e.next; e.next.previous = e.previous; e.next = e.previous = null; e.element = null; size--; modCount++; return result; &#125; ##Java 集合中常见 checkForComodification()方法的作用? modCount和expectedModCount作用? Node的查找加速12345678910111213141516171819202122/** * 源码中先将index与长度size的一半比较，if index &lt; (size &gt;&gt; 1)，就只从位置0往后遍历到位置index处， * 而如果index &gt; (size &gt;&gt; 1)，就只从位置size往前遍历到位置index处。 * 这样可以减少一部分不必要的遍历，从而提高一定的效率（实际上效率还是很低）。 * JDK1.8这里用的是位运算 ， 而JDK1.6 用的是判断index&lt;size/2 * Returns the (non-null) Node at the specified element index. */Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 每次看都有新发现，都会更新记录！","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dwxnqswxl.cn/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.dwxnqswxl.cn/tags/基础/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://www.dwxnqswxl.cn/tags/源码阅读/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://www.dwxnqswxl.cn/tags/LinkedList/"}]},{"title":"Java 集合中常见 checkForComodification() 方法的作用？","slug":"YM00000004","date":"2018-08-03T06:23:44.000Z","updated":"2018-08-24T02:11:57.120Z","comments":true,"path":"2018/08/03/YM00000004/","link":"","permalink":"https://www.dwxnqswxl.cn/2018/08/03/YM00000004/","excerpt":"","text":"Java 集合中常见 checkForComodification() 方法的到底有什么作用？还有 modCount 和 expectedModCount 作用？ 主要是用来实现 fail-fast 机制 有两个线程（线程 A，线程 B），其中线程 A 负责遍历 list、线程 B 修改 list。 -线程 A 在遍历 list 过程的某个时候（此时 expectedModCount = modCount=N），线程启动，同时线程 B 增加一个元素，这是 modCount 的值发生改变（modCount + 1 = N + 1）。 线程 A 继续遍历执行 next 方法时，通告 checkForComodification 方法发现 expectedModCount = N ， 而 modCount = N + 1，两者不等，这时就抛出 ConcurrentModificationException 异常，从而产生 fail-fast 机制。 12345678910111213141516171819202122232425262728293031/** * 当前取的是 JDK1.8 ArrayList中的代码 *//** * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;. * Structural modifications are those that change the size of the * list, or otherwise perturb it in such a fashion that iterations in * progress may yield incorrect results. * * &lt;p&gt;This field is used by the iterator and list iterator implementation * returned by the &#123;@code iterator&#125; and &#123;@code listIterator&#125; methods. * If the value of this field changes unexpectedly, the iterator (or list * iterator) will throw a &#123;@code ConcurrentModificationException&#125; in * response to the &#123;@code next&#125;, &#123;@code remove&#125;, &#123;@code previous&#125;, * &#123;@code set&#125; or &#123;@code add&#125; operations. This provides * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in * the face of concurrent modification during iteration. * * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass * wishes to provide fail-fast iterators (and list iterators), then it * merely has to increment this field in its &#123;@code add(int, E)&#125; and * &#123;@code remove(int)&#125; methods (and any other methods that it overrides * that result in structural modifications to the list). A single call to * &#123;@code add(int, E)&#125; or &#123;@code remove(int)&#125; must add no more than * one to this field, or the iterators (and list iterators) will throw * bogus &#123;@code ConcurrentModificationExceptions&#125;. If an implementation * does not wish to provide fail-fast iterators, this field may be * ignored. */protected transient int modCount = 0; 在父类 AbstractList 中定义了一个 int 型的属性：modCount 1protected transient int modCount = 0; 在 ArrayList 的所有涉及结构变化的方法中都增加 modCount 的值，包括：add()、remove()、addAll()、removeRange()及 clear()方法。这些方法每调用一次，modCount 的值就加 1。注：add()及addAll()方法的modCount的值是在其中调用的ensureCapacity()方法中增加的。AbstractList 中的 iterator()方法（ArrayList 直接继承了这个方法）使用了一个私有内部成员类 Itr，生成一个 Itr 对象（Iterator 接口）返回： 1public Iterator iterator() &#123; return new Itr(); &#125; Itr 实现了 Iterator()接口，其中也定义了一个 int 型的属性：expectedModCount，这个属性在 Itr 类初始化时被赋予 ArrayList 对象的 modCount 属性的值。 1int expectedModCount = modCount; 注：内部成员类Itr也是ArrayList类的一个成员，它可以访问所有的AbstractList的属性和方法。理解了这一点，Itr类的实现就容易理解了。 在 Itr.hasNext()方法中： 1public boolean hasNext() &#123; return cursor != size; &#125; 调用了 AbstractList 的 size，比较当前光标位置是否越界。 12345678910111213141516171819202122232425public Object next()&#123; try &#123; Object next = get(cursor); checkForComodification(); lastRet = cursor++; return next; &#125; catch(IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125;&#125;/*** 在对一个集合对象进行跌代操作的同时，并不限制对集合对象的元素进行操作* 这些操作包括一些可能引起跌代错误的add()或remove()等危险操作。* 在AbstractList中，使用了一个简单的机制来规避这些风险。* 这就是modCount和expectedModCount的作用所在*/final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dwxnqswxl.cn/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.dwxnqswxl.cn/tags/基础/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://www.dwxnqswxl.cn/tags/源码阅读/"}]},{"title":"ArrayList（JDK1.8） 源码阅读记录","slug":"YM00000005","date":"2018-08-03T02:59:08.000Z","updated":"2018-08-27T09:06:43.018Z","comments":true,"path":"2018/08/03/YM00000005/","link":"","permalink":"https://www.dwxnqswxl.cn/2018/08/03/YM00000005/","excerpt":"","text":"ArrayListArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。 ArrayList不是线程安全的，只能用在单线程环境下 多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类 也可以使用concurrent并发包下的CopyOnWriteArrayList类 ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输 实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问 实现了Cloneable接口，能被克隆 根据JDK版本的不同 ，构造方法也不同123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/*** JDK 1.8*//** * Default initial capacity. */private static final int DEFAULT_CAPACITY = 10;/** * first element is added. * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * Shared empty array instance used for empty instances. */private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * 上面这个对象数组就是其存储元素的数据结构，前面有一个java关键字transient * 这个关键字是去序列化的意思，即，在这个类序列化后保存到磁盘或者输出到输出流的时候 * 这个对象数组是不被保存或者输出的。(这个不是下面的翻译，对transient解释) * * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access/** * ArrayList带容量大小的构造函数。 * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125;/** * 无参构造方法构造的ArrayList的默认返回空数组 * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;/** * 带有Collection参数的构造方法 * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125;/*** JDK 1.7/1.6*//** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity]; &#125; /** * 无参构造直接返回了this（10）;默认10 这也是与1.8不同的地方 * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this(10); &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * 在这1.8也多了一个判断 * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; 为什么用到 transient？这就跟这个ArrayList的特性有关，我们知道ArrayList的容量，也就是这个数组的容量，一般都是预留一些容量，等到容量不够时再拓展，那么就会出现容量还有冗余的情况，如果这时候进行序列化，整个数组都会被序列化，连后面没有意义空元素的也被序列化。这些是不应该被存储的。所以java的设计者，就为这个类提供了一个writeObject方法，在实现了Serializable接口的类，如果这个类提供了writeObject方法，那么在进行序列化的时候就会通过writeObject方法进行序列化，所以ArrayList的writeObject方法就会显式的为每个实际的数组元素进行序列化，只序列化有用的元素。 为什么源码中大量地调用了Arrays.copyof()和System.arraycopy()方法?1234567891011public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass());&#125;public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 最后都调用了System.arraycopy（）方法。 12345678910/*** 该方法被标记了native，调用了系统的C/C++代码，在JDK中是看不到的，* 但在openJDK中可以看到其源码。该函数实际上最终调用了C语言的memmove()函数，* 因此它可以保证同一个数组内元素的正确复制 和移动，比一般的复制方法的实现效率要高很多，* 很适合用来批量处理数组。Java强烈推荐在复制大量数组元素时用该方法，以取得更高的效率。* 这也说明了ArrayList 与数组*/ public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); JDK1.6 开始扩容办法也不一样123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * JDK1.6 * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; &#125; /** * JDK1.8 */ /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; 1.7JDK开始使用的是位运算 在算出newCapacity时，其没有和ArrayList所定义的MAX_ARRAY_SIZE作比较，为什么没有进行比较呢，原因是jdk1.6没有定义这个MAX_ARRAY_SIZE最大容量，也就是说，其没有最大容量限制的，但是jdk1.7以上做了一个改进，进行了容量限制。 Java 集合中常见 checkForComodification()方法的作用? modCount和expectedModCount作用? ArrayList 快速访问ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。 1234567/*** 先检查索引 然后校验操作正确*/public E get(int var1) &#123; this.rangeCheck(var1); return this.elementData(var1);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dwxnqswxl.cn/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.dwxnqswxl.cn/tags/基础/"},{"name":"源码阅读","slug":"源码阅读","permalink":"https://www.dwxnqswxl.cn/tags/源码阅读/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://www.dwxnqswxl.cn/tags/ArrayList/"}]},{"title":"Leetcode - 从排序数组中删除重复项","slug":"LC00000001","date":"2018-01-30T07:02:28.000Z","updated":"2018-08-24T03:10:38.796Z","comments":true,"path":"2018/01/30/LC00000001/","link":"","permalink":"https://www.dwxnqswxl.cn/2018/01/30/LC00000001/","excerpt":"","text":"问题描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解答12345678910111213141516171819202122@Testpublic void testRemoveDuplicates() &#123; int[] nums = &#123;1, 1, 2, 2, 3, 3&#125;; int len = removeDuplicates(nums); for (int i = 0; i &lt; len; i++) &#123; System.out.print(nums[i]); &#125;&#125;public static int removeDuplicates(int[] nums) &#123; int count = 0; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != nums[count]) &#123; count++; nums[count] = nums[i]; &#125; &#125; count++; return count;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.dwxnqswxl.cn/categories/leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.dwxnqswxl.cn/tags/Array/"},{"name":"算法","slug":"算法","permalink":"https://www.dwxnqswxl.cn/tags/算法/"}]},{"title":"Leetcode - 旋转数组","slug":"LC00000003","date":"2018-01-30T07:02:28.000Z","updated":"2018-08-24T03:10:51.353Z","comments":true,"path":"2018/01/30/LC00000003/","link":"","permalink":"https://www.dwxnqswxl.cn/2018/01/30/LC00000003/","excerpt":"","text":"问题描述给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: [1,2,3,4,5,6,7] 和 k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右旋转 1 步: [7,1,2,3,4,5,6] 向右旋转 2 步: [6,7,1,2,3,4,5] 向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入: [-1,-100,3,99] 和 k = 2 输出: [3,99,-1,-100] 解释: 向右旋转 1 步: [99,-1,-100,3] 向右旋转 2 步: [3,99,-1,-100] 说明尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的原地算法。 解答one1234567891011121314151617181920212223242526@Testpublic void testRotate() &#123; int[] arrays = &#123;1&#125;; rotate(arrays, 3); for (int i = 0; i &lt; arrays.length; i++) &#123; System.out.print(arrays[i]); &#125;&#125;public static void rotate(int[] arrays, int k) &#123; if (0 &gt;= k) &#123; return; &#125; for (int i = 0; i &lt; k; i++) &#123; int last = arrays[arrays.length - 1]; int first = arrays[0]; for (int j = 1; j &lt; arrays.length; j++) &#123; last = arrays[j]; arrays[j] = first; first = last; &#125; arrays[0] = last; &#125;&#125; two1234567891011121314151617181920public void rotate(int[] nums, int k) &#123; if (nums.length == 0) &#123; return; &#125; k = k % nums.length; reverse(nums, 0, nums.length - k - 1); reverse(nums, nums.length - k, nums.length - 1); reverse(nums, 0, nums.length - 1);&#125;private void reverse(int[] nums, int start, int end) &#123; while (start &lt; end) &#123; int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; &#125;&#125; three12345678910111213141516171819202122232425262728/** * (k+i)%n 计算出新的位置 */public void rotate(int[] nums, int k) &#123; k = k % nums.length; if(k ==0 || nums.length == 1) return; int N=nums.length; int n=0; int i=0; int times=0; int cur=nums[0]; // n==N out while(n&lt;N)&#123; // 计算的i 可能和之前的冲突，移到下一个i，再计算 i=(k+i)%N; int t = nums[i]; nums[i] = cur; if(i==times)&#123; times++; i++; cur = nums[i]; &#125;else&#123; cur = t; &#125; n++; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.dwxnqswxl.cn/categories/leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.dwxnqswxl.cn/tags/Array/"},{"name":"算法","slug":"算法","permalink":"https://www.dwxnqswxl.cn/tags/算法/"}]},{"title":"Leetcode - 买卖股票的最佳时机 II","slug":"LC00000002","date":"2018-01-30T07:02:28.000Z","updated":"2018-08-24T03:10:45.205Z","comments":true,"path":"2018/01/30/LC00000002/","link":"","permalink":"https://www.dwxnqswxl.cn/2018/01/30/LC00000002/","excerpt":"","text":"问题描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解答123456789101112131415161718@Testpublic void testMaxProfit() &#123; int[] nums = &#123;7, 1, 5, 3, 6, 4&#125;; int max = maxProfit(nums); System.out.println(max);&#125;public static int maxProfit(int[] prices) &#123; int maxPrice = 0; for (int i = 0; i &lt; prices.length - 1; i++) &#123; if ((prices[i] &lt; prices[i + 1])) &#123; int discount = prices[i + 1] - prices[i]; maxPrice = maxPrice + (discount &gt; 0 ? discount : 0); &#125; &#125; return maxPrice;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.dwxnqswxl.cn/categories/leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.dwxnqswxl.cn/tags/Array/"},{"name":"算法","slug":"算法","permalink":"https://www.dwxnqswxl.cn/tags/算法/"}]},{"title":"Leetcode - 两数之和","slug":"LC00000004","date":"2018-01-30T07:02:28.000Z","updated":"2018-08-24T03:10:59.379Z","comments":true,"path":"2018/01/30/LC00000004/","link":"","permalink":"https://www.dwxnqswxl.cn/2018/01/30/LC00000004/","excerpt":"","text":"问题描述给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 解答123456789101112131415161718192021@Testpublic void testTwoSum() &#123; int[] arrays = &#123;3, 3&#125;; arrays = twoSum(arrays, 6); for (int i = 0; i &lt; arrays.length; i++) &#123; System.out.println(arrays[i]); &#125;&#125;public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; int component = target - nums[i]; if(map.containsKey(component))&#123; return new int[]&#123;map.get(component),i&#125;; &#125; else &#123; map.put(nums[i],i); &#125; &#125; throw new IllegalArgumentException(\"error\");&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.dwxnqswxl.cn/categories/leetcode/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://www.dwxnqswxl.cn/tags/Array/"},{"name":"算法","slug":"算法","permalink":"https://www.dwxnqswxl.cn/tags/算法/"}]},{"title":"java进阶 - 经典排序","slug":"JC00000004","date":"2018-01-30T07:02:28.000Z","updated":"2018-08-24T03:10:27.929Z","comments":true,"path":"2018/01/30/JC00000004/","link":"","permalink":"https://www.dwxnqswxl.cn/2018/01/30/JC00000004/","excerpt":"","text":"业余时间学习java，回顾经典算法。插入排序 插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 —— [ 百度百科 ] 代码123456789101112131415161718192021 /** * 插入排序 */ public void insertSort(int[] array) &#123; System.out.println(\"-----Start 插入排序-----\"); System.out.println(Arrays.toString(array)); for (int i = 0; i &lt; array.length; i++) &#123; int j = i - 1; int temp = array[i]; while (j &gt; -1 &amp;&amp; temp &lt; array[j]) &#123; array[j + 1] = array[j]; j--; &#125; if (temp == array[i]) &#123; continue; &#125; array[j + 1] = temp; &#125; System.out.println(Arrays.toString(array)); System.out.println(\"-----End 插入排序-----\");&#125; 运行结果1234-----Start 插入排序-----[14, 21, 12, 5, 7][5, 7, 12, 14, 21]-----End 插入排序----- 冒泡排序 冒泡排序算法的运作如下：（从后往前）比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 —— [ 百度百科 ] 代码12345678910111213141516171819202122 /** * 冒泡排序（Bubble Sort） */public void bubbleSort(int[] array) &#123; System.out.println(\"-----Start 冒泡排序-----\"); System.out.println(Arrays.toString(array)); int temp = 0; for (int i = array.length - 1; i &gt; 0; --i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (array[j + 1] &lt; array[j]) &#123; temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; System.out.println(Arrays.toString(array)); System.out.println(\"-----End 冒泡排序-----\");&#125; 运行结果1234-----Start 冒泡排序-----[5, 7, 12, 14, 21][5, 7, 12, 14, 21]-----End 冒泡排序----- 快速排序 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 —— [ 百度百科 ] 代码12345678910111213141516171819202122232425262728293031323334private int count = 0;/** * 快速排序（Bubble Sort） * @param array * @param l * @param r */public void quickSort(int[] array, int l, int r) &#123; if (l &lt; r) &#123; int i = l, j = r, x = array[l]; while (i &lt; j) &#123; // 从右向左找第一个小于x的数 while(i &lt; j &amp;&amp; array[j] &gt;= x) j--; if(i &lt; j) array[i++] = array[j]; // 从左向右找第一个大于等于x的数 while(i &lt; j &amp;&amp; array[i] &lt; x) i++; if(i &lt; j) array[j--] = array[i]; &#125; array[i] = x; count ++; System.out.println(\"-----第\"+count+\"次快速排序-----\"); System.out.println(Arrays.toString(array)); // 递归调用 quickSort(array, l, i - 1); quickSort(array, i + 1, r); &#125;&#125; 运行结果123456789101112131415161718192021int[] outOrder = &#123;14, 21, 12, 5, 7,9,55,77,33,12,65,6&#125;;运行结果：-----第1次快速排序-----[6, 12, 12, 5, 7, 9, 14, 77, 33, 55, 65, 21]-----第2次快速排序-----[5, 6, 12, 12, 7, 9, 14, 77, 33, 55, 65, 21]-----第3次快速排序-----[5, 6, 9, 7, 12, 12, 14, 77, 33, 55, 65, 21]-----第4次快速排序-----[5, 6, 7, 9, 12, 12, 14, 77, 33, 55, 65, 21]-----第5次快速排序-----[5, 6, 7, 9, 12, 12, 14, 21, 33, 55, 65, 77]-----第6次快速排序-----[5, 6, 7, 9, 12, 12, 14, 21, 33, 55, 65, 77]-----第7次快速排序-----[5, 6, 7, 9, 12, 12, 14, 21, 33, 55, 65, 77]-----第8次快速排序-----[5, 6, 7, 9, 12, 12, 14, 21, 33, 55, 65, 77]Process finished with exit code 0 待更新","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dwxnqswxl.cn/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.dwxnqswxl.cn/tags/基础/"},{"name":"插入排序","slug":"插入排序","permalink":"https://www.dwxnqswxl.cn/tags/插入排序/"},{"name":"冒泡排序","slug":"冒泡排序","permalink":"https://www.dwxnqswxl.cn/tags/冒泡排序/"},{"name":"快速排序","slug":"快速排序","permalink":"https://www.dwxnqswxl.cn/tags/快速排序/"}]},{"title":"java进阶 - 常用数据结构以及算法思想","slug":"JC00000001","date":"2017-12-16T02:33:38.000Z","updated":"2018-08-24T02:28:22.941Z","comments":true,"path":"2017/12/16/JC00000001/","link":"","permalink":"https://www.dwxnqswxl.cn/2017/12/16/JC00000001/","excerpt":"","text":"常用数据结构数组、链表、堆、栈、队列、Hash表、二叉树等 算法思想算法时间复杂度和空间复杂度的分析计算算法思想：递推、递归、穷举、贪心、分治、动态规划、迭代、分枝界限 以下是部分代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349package com.cn.learn;import com.cn.entity.Goods;import org.junit.Test;import java.util.*;/** * 描述:算法学习 * * @outhor hjx * @create 2017-12-05 11:09 */public class LearnArithmeticTest&#123; private static int count = 0; /** * 递推的经典算法 * 1.兔子数列demo * 斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci[1] ） * 以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上 * 斐波纳契数列以如下被以递归的方法定义：F（0）=0，F（1）=1，F（n）=F(n-1)+F(n-2)（n≥2，n∈N*） * 在现代物理、准晶体结构、化学等领域，斐波纳契数列都有直接的应用 * * 2.Hanoi塔 *设hn为n个盘子从a柱移到c柱所需移动的盘次。 * 显然，当n=1时，只需把a 柱上的盘子直接移动到c柱就可以了， * 故h1=1。当n=2时，先将a柱上面的小盘子移动到b柱上去; * 然后将大盘子从a柱移到c 柱；最后，将b柱上的小盘子移到c柱上，共记3个盘次，故h2=3。 * 以此类推，当a柱上有n(n2)个盘子时，总是先借助c柱把上面的n-1个盘子移动到b柱上， * 然后把a柱最下面的盘子移动到c柱上；再借助a柱把b柱上的n-1个盘子移动到c柱上；总共移动hn-1+1+hn-1个盘次。 * ∴hn=2hn-1+1 边界条件：h1=1 * and so on; */ @Test public void learn1()&#123; int n = 3; System.out.println(\"经历了多少个月:\"+n); System.out.println(calc(n)); System.out.println(\"罗盘:\"+n); System.out.println(hanoi(n)); &#125; public static int calc(int month)&#123; if (month == 1 || month == 2)&#123; return 1; &#125;else&#123; return calc(month-1) + calc(month-2); &#125; &#125; public static int hanoi(int n)&#123; if (n == 1)&#123; return 1; &#125;else&#123; return 2*hanoi(n-1)+1; &#125; &#125; /** * 递归算法 * hanoi 算移动 * */ @Test public void learn2()&#123; move(4,\"A\",\"B\",\"C\"); System.out.println(\"移动次数 :\"+count); &#125; /** * 算移动次数以及如何移动 * @param n 总数 * @param p1 1 * @param p2 2 * @param p3 3 */ public void move(int n,String p1,String p2,String p3)&#123; if (n == 1)&#123; System.out.println(\"从 \"+p1+\" ----&gt; \"+p3); count += 1; &#125;else&#123; move(n-1,p1,p3,p2); System.out.println(\"从 \"+p1+\" ----&gt; \"+p3); count += 1; move(n-1,p2,p1,p3); &#125; &#125; /** * 穷举法 * 例子 鸡兔同笼 */ @Test public void learn3()&#123; calc03(21,94); &#125; /** * 例子 鸡兔同笼 * @param head 头的个数 * @param foot 腿的个数 * */ public void calc03 (int head,int foot)&#123; int chicken,rabbit; boolean flag = false; for(chicken = 0;chicken&lt;=head;chicken++)&#123; rabbit = head - chicken; if(chicken*2+rabbit*4 == foot)&#123; flag = true; System.out.println(String.format(\"鸡有\"+chicken+\"只，兔子有\"+rabbit+\"只\")); &#125; &#125; if (flag == false)&#123; System.out.println(head + \"个头的数量和\"+foot+\"个腿的数量不对！\"); &#125; &#125; /** * 贪心算法 * 例子 经典的背包问题(不包括0-1背包问题) */ @Test public void learn04()&#123; List&lt;Goods&gt; list = new ArrayList&lt;Goods&gt;(); Goods goods1 = new Goods(1,5,20); Goods goods2 = new Goods(2,2,10); Goods goods3 = new Goods(3,3,10); Goods goods4 = new Goods(4,2,4); Goods goods5 = new Goods(5,7,100); Goods goods6 = new Goods(6,2,5); list.add(goods1); list.add(goods2); list.add(goods3); list.add(goods4); list.add(goods5); list.add(goods6); Collections.sort(list); &#125; /** * 位运算 * 都是基础 * 由位运算操作符衍生而来的有： * &amp;= 按位与赋值 * |= 按位或赋值 * ^= 按位非赋值 * &gt;&gt;= 右移赋值 * &gt;&gt;&gt;= 无符号右移赋值 * &lt;&lt;= 赋值左移 */ @Test public void dynamic()&#123; /** * 左移 运行结果是20 */ System.out.println(5&lt;&lt;2); /** * 右移 运行结果是1 */ System.out.println(5&gt;&gt;2); /** * 无符号右移 * 结果是536870911 高位补0所以变成正的 */ System.out.println(-5&gt;&gt;&gt;3); /** * 与 &amp; 运行结果是1 */ System.out.println(5&amp;3); /** * 或 | 运行结果 7 */ System.out.println(5|3); /** * 非 ~ 结果为-6 */ System.out.println(~5); /** * 异或 ^ 结果为6 */ System.out.println(5^3); System.out.println(8&gt;&gt;2); &#125; /** * 动态规划(问题建模) * 1.最优子结构 * 2.边界 * 3.状态转移方程 * 简单的动态规划问题 * 问题1:有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。 * 问题2:有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。 * 每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？ * 400金/5人 500金/5人 200金/3人 300金/4人 350金/3人 */ @Test public void learndynamic()&#123; //问题1 System.out.println(calcDynamic01(10)); &#125; /** * 问题1:有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。 * n为楼梯的高度 * 问题建模: * 1.最优子结构 * F(10) = F(9)+F(8) * 2.边界（当楼梯为1或者2时可以直接得出结论） * F(1) = 1 * F(2) = 2 * 3.状态转移方程 * F（n） = F(n-1)+ F(n-2) * @param n */ public int calcDynamic01(int n)&#123; if (n &lt; 1)&#123; return 0;&#125; if (n == 1)&#123; return 1;&#125; if (n == 2)&#123; return 2;&#125; int a = 1; int b = 2; int temp = 0 ; for(int i=3;i&lt;=n;i++)&#123; temp = a+b; a = b; b =temp; &#125; return temp; &#125; /** * 有一个国家发现了5座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是10人。 * 每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？ * 400金/5人 500金/5人 200金/3人 300金/4人 350金/3人 * 问题建模： * 1.最优子结构 * 四金矿 10工人 或者 四金矿 10-3工人 * F(5,10) = MAX(F(4,10),F(4,10-P(4))+G(4)) * 2.边界 * 当N=1,W&gt;=P[0]时，F(N.W) = G[0] * 当N=1,W&lt;P[0]时，F(N.W) = 0 * 3.状态转移方程 * F(n,w) = F(n-1,w) (n&gt;1, w&lt;p[n-1]) ----&gt; F(n,w) = max(F(n-1,w), F(n-1,w-p[n-1])+g[n-1]) (n&gt;1, w&gt;=p[n-1]) * * @param n 金矿数量 * @param w 工人数 * @param g 黄金量 * @param p 金矿用工量 * @return 最大值 */ public int calcGold(int n,int w,int[] g,int[] p)&#123; int[] preResult = new int[p.length]; int[] results = new int[p.length]; for(int i=0;i&lt;=n;i++)&#123; if (i&lt;p[0])&#123; preResult[i] = 0; &#125;else&#123; preResult[i] = g[0]; &#125; &#125; // 外层循环 金矿数量 内层循环 工人数量 for (int i=0;i&lt;n;i++)&#123; for (int j=0;j&lt;=w;j++)&#123; if (j&lt;p[i])&#123; results[j] = preResult[j]; &#125;else&#123; results[j] = Math.max(preResult[j],preResult[j-p[i]]+g[i]); &#125; &#125; preResult = results; &#125; return results[n]; &#125; /** * 动态规划 * 核心理解 * 1.最优子结构 * 总价值 tab(i+1) = max( tab(i) + v(i+1) , tab(i) ) 寻找最优解子结构 * 重量 j(i+1) = j(i) + w(i+1) * 2.边界 * 3.状态转移方程 * total[i][j] = max(total[i-1][j-weight[i]]+value[i],total[i-1][j]) (&#123;i,j|0&lt; i &lt;=n,0&lt;= j &lt;=packMax&#125;) * 0-1 背包问题 */ @Test public void pack()&#123; //物品重量 int[] weight = &#123;5,2,3,2,7,2&#125;; //物品价值 int[] val = &#123;20,10,10,4,100,5&#125;; //背包容量 int m = 15; //物品个数 int n = val.length; //f[i][j]表示前i个物品能装入容量为j的背包中的最大价值 int[][] f = new int[n+1][m+1]; int[][] path = new int[n+1][m+1]; //初始化第一列和第一行 for(int i=0;i&lt;f.length;i++)&#123; f[i][0] = 0; &#125; for(int i=0;i&lt;f[0].length;i++)&#123; f[0][i] = 0; &#125; /** * 通过公式迭代计算 */ for(int i=1;i&lt;f.length;i++)&#123; for(int j=1;j&lt;f[0].length;j++)&#123; if(weight[i-1]&gt;j)&#123; f[i][j] = f[i-1][j]; &#125;else&#123; if(f[i-1][j]&lt;f[i-1][j-weight[i-1]]+val[i-1])&#123; f[i][j] = f[i-1][j-weight[i-1]]+val[i-1]; path[i][j] = 1; &#125;else&#123; f[i][j] = f[i-1][j]; &#125; &#125; &#125; &#125; for(int i=0;i&lt;f.length;i++)&#123; for(int j=0;j&lt;f[0].length;j++)&#123; System.out.print(f[i][j]+\" \"); &#125; System.out.println(); &#125; int i=f.length-1; int j=f[0].length-1; while(i&gt;0&amp;&amp;j&gt;0)&#123; if(path[i][j] == 1)&#123; System.out.print(\"第\"+i+\"个物品装入 \"); j -= weight[i-1]; &#125; i--; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dwxnqswxl.cn/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.dwxnqswxl.cn/tags/基础/"},{"name":"递推","slug":"递推","permalink":"https://www.dwxnqswxl.cn/tags/递推/"},{"name":"递归","slug":"递归","permalink":"https://www.dwxnqswxl.cn/tags/递归/"},{"name":"穷举","slug":"穷举","permalink":"https://www.dwxnqswxl.cn/tags/穷举/"},{"name":"贪心","slug":"贪心","permalink":"https://www.dwxnqswxl.cn/tags/贪心/"},{"name":"分治","slug":"分治","permalink":"https://www.dwxnqswxl.cn/tags/分治/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.dwxnqswxl.cn/tags/动态规划/"}]},{"title":"Map遍历","slug":"JC00000003","date":"2017-12-01T03:39:32.000Z","updated":"2018-08-24T02:20:57.036Z","comments":true,"path":"2017/12/01/JC00000003/","link":"","permalink":"https://www.dwxnqswxl.cn/2017/12/01/JC00000003/","excerpt":"","text":"Map遍历Map遍历的时候推荐使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。说明：keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效 率更高。如果是 JDK8，使用 Map.foreach 方法。 ———— 取自阿里巴巴java开发手册 1234567891011121314151617181920@Testpublic void testMapEntry() &#123; Map&lt;String, String&gt; request = new HashMap&lt;&gt;(); request.put(\"1\", \"hello\"); request.put(\"2\", \"world\"); StringBuilder sb = new StringBuilder(); for (Map.Entry&lt;String, String&gt; entry : request.entrySet()) &#123; sb.append(entry.getValue()); &#125; System.out.println(sb.toString()); /** * jdk 1.8 lambda 表达式 */ request.forEach((K, V) -&gt; &#123; System.out.print(K); System.out.println(\":\" + V); &#125;);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dwxnqswxl.cn/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.dwxnqswxl.cn/tags/基础/"},{"name":"HashMap","slug":"HashMap","permalink":"https://www.dwxnqswxl.cn/tags/HashMap/"}]},{"title":"Java 8 - lambda","slug":"JC00000005","date":"2017-11-30T03:39:32.000Z","updated":"2018-08-24T04:26:02.031Z","comments":true,"path":"2017/11/30/JC00000005/","link":"","permalink":"https://www.dwxnqswxl.cn/2017/11/30/JC00000005/","excerpt":"","text":"lambda学习记录 lambda，java 8 引入 lambda 将是对使用集合的一次重大改变，虽然看着很难懂，但是用着用着就好了，本文将用几个例子举例,本文参考的网上的一些例子。违删。新手挑战区。 lambda 主要的表示形式 (params) -&gt; expression(params) -&gt; statement(params) -&gt; { statements } Example（） - &gt; System.out.println(“ Lambda Expressions”);(int i, int j) -&gt; System.out.println(i+j); Example No.1 遍历数组等 1234List features = Arrays.asList(\"Lambdas\", \"Method\", \"Java\", \"Hello\");features.forEach(n -&gt; System.out.println(n));// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，features.forEach(System.out::println); Example No.2 获取数字的个数、最小值、最大值、总和以及平均值 123456List&lt;Integer&gt; primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);IntSummaryStatistics stats = primes.stream().mapToInt((x) -&gt; x).summaryStatistics();System.out.println(\"Highest prime number in List : \" + stats.getMax());System.out.println(\"Lowest prime number in List : \" + stats.getMin());System.out.println(\"Sum of all prime numbers : \" + stats.getSum());System.out.println(\"Average of all prime numbers : \" + stats.getAverage()); 结果：Highest prime number in List : 29Lowest prime number in List : 2Sum of all prime numbers : 129Average of all prime numbers : 12.9 Example No.3 map - reduce 例子 123456List&lt;Integer&gt; costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);//这个是将每个数都变成浮点数 * 12costBeforeTax.stream().map((cost) -&gt; cost + .12 * cost ).forEach(System.out::println);//这个是将每个数都变成浮点数 * 12 然后再算和double bill = costBeforeTax.stream().map((cost) -&gt; cost + .12*cost).reduce((sum, cost) -&gt; sum + cost).get();System.out.println(\"Total : \" + bill); 结果：112.0224.0336.0448.0560.0Total : 1680.0 12345map---对列表的每个元素应用函数使用// 将字符串换成大写并用逗号链接起来List&lt;String&gt; G7 = Arrays.asList(\"USA\", \"Japan\", \"France\", \"Germany\", \"Italy\", \"U.K.\",\"Canada\");String G7Countries = G7.stream().map(x -&gt; x.toUpperCase()).collect(Collectors.joining(\", \"));System.out.println(G7Countries); Example No.4 匿名类 12345678910111213// Java 8之前：new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Rock it!\"); System.out.println(\"Hello world\"); &#125;&#125;).start();//java8 支持 new Thread (() -&gt; &#123; System.out.println(\"Rock it!\"); System.out.println(\"hello world!\"); &#125;).start(); 结果：Rock it!Hello world! Example No.5 函数式接口 PredicateJava 8 也添加了一个包，叫做 java.util.function。它包含了很多类，用来支持 Java 的函数式编程。其中一个便是 Predicate，使用 java.util.function.Predicate 函数式接口以及 lambda 表达式，可以向 API 方法添加逻辑，用更少的代码支持更多的动态行为。下面是 Java 8 Predicate 的例子，展示了过滤集合数据的多种常用方法。Predicate 接口非常适用于做过滤。 12345678// 甚至可以用and()、or()和xor()逻辑函数来合并Predicate，// 例如要找到所有以J开始，长度为四个字母的名字，你可以合并两个Predicate并传入List&lt;String&gt; languages = Arrays.asList(\"Java\", \"Scala\", \"C++\", \"Haskell\", \"Lisp\",\"h\",\"d\",\"map\",\"r\");Predicate&lt;String&gt; startsWithJ = (n) -&gt; n.startsWith(\"J\");Predicate&lt;String&gt; fourLetterLong = (n) -&gt; n.length() == 4;languages.stream() .filter(startsWithJ.and(fourLetterLong)) .forEach((n) -&gt; System.out.print(\"nName, which starts with 'J' and four letter long is : \" + n)); 运行结果Original List : [Java, Scala, C++, Haskell, Lisp, h, d, map, r], filtered list : [Java, Scala, C++, Haskell, Lisp, map]","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dwxnqswxl.cn/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.dwxnqswxl.cn/tags/基础/"},{"name":"lambda","slug":"lambda","permalink":"https://www.dwxnqswxl.cn/tags/lambda/"}]},{"title":"java边遍历边删除的问题(ConcurrentModificationException异常)","slug":"JC00000002","date":"2017-11-30T03:39:32.000Z","updated":"2018-08-24T02:21:59.558Z","comments":true,"path":"2017/11/30/JC00000002/","link":"","permalink":"https://www.dwxnqswxl.cn/2017/11/30/JC00000002/","excerpt":"","text":"为什么java边遍历边删除会报ConcurrentModificationException异常呢？请参考这个Java集合中常见checkForComodification()方法的作用？还有 modCount 和 expectedModCount 作用？ 增强循环 使用迭代器123456789101112131415161718192021222324252627282930313233/** * 使用迭代器 * （不推荐使用 users.remove() 继续循环List时会报ConcurrentModificationException） */public static void list()&#123; List&lt;User&gt; users = getUsers(); Iterator&lt;User&gt; iterator = users.iterator(); while (iterator.hasNext())&#123; //删除判断条件 if (iterator.next().getId()&gt;0 &amp;&amp; iterator.next().getId()&lt;3)&#123; iterator.remove(); &#125; &#125; for (User user:users)&#123; System.out.println(user.getName()); &#125;&#125;/** * 使用迭代器 */public static void set()&#123; Set&lt;User&gt; users = getSetUsers(); Iterator&lt;User&gt; iterator = users.iterator(); while (iterator.hasNext())&#123; //删除判断条件 if (iterator.next().getId()&gt;0 &amp;&amp; iterator.next().getId()&lt;3)&#123; iterator.remove(); &#125; &#125; for (User user:users)&#123; System.out.println(user.getName()); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dwxnqswxl.cn/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://www.dwxnqswxl.cn/tags/基础/"},{"name":"List","slug":"List","permalink":"https://www.dwxnqswxl.cn/tags/List/"}]}]}